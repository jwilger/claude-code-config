# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development Commands

### Testing

Always use `{{testRunner}}` instead of `{{testCommandFallback}}`:

```bash
{{testRunner}}                    # Run all tests
{{testRunner}} --lib             # Unit tests only
{{testRunner}} --tests           # Integration tests only
{{testRunner}} --nocapture       # Show test output
{{testBacktraceEnv}}=1 {{testRunner}}  # With backtrace on failure
```

### Building and Linting

```bash
{{buildCommand}}                          # Build the project
{{buildRelease}}              # Release build
{{checkCommand}}                         # Fast syntax/type checking
{{lintCommand}}                        # Linting (strict rules enabled)
{{formatCommand}}                          # Format code
```

### Development Tools

```bash
{{watchCommand}}                 # Auto-run tests on changes
{{expandCommand}}                       # Macro expansion
{{editCommand}}                         # Dependency management
```

<!-- Project-specific architecture, components, and code structure belong in CLAUDE.local.md -->

## Development Conventions

**Universal Conventions:**
- **Dependency Management**: Always use package manager CLI tools (`{{addCommand}}`, `{{removeCommand}}`) to install/update dependencies. Never manually edit {{configFile}} version numbers. This ensures we use the latest compatible versions and avoid version conflicts.

{{languageDevelopmentConventionsContent}}

## External Dependencies

The project uses Nix for development environment management:

- Ad-hoc tools: use `nix shell` to use a tool that is not currently installed
- Update Flake: For tools you regularly use, consider adding them to the flake.nix file

{{languageDependencyContent}}

## Type-Driven Development Rules

**Universal Principles:**
- **Illegal states are unrepresentable**: prefer domain types over primitives
- Use smart constructors with validation rather than exposing raw data
- Prefer explicit error types over exceptions/panics for recoverable errors
- Make invalid states impossible through the type system

{{languageTypeSystemContent}}

## Code Quality Enforcement - CRITICAL

**NEVER BYPASS LINTERS WITH INLINE OVERRIDES** - This is a hard rule with zero exceptions without team approval.

**Universal Rules:**
- **NEVER** bypass linters or ignore warnings/errors with inline directives
- **ALWAYS** fix the underlying issue causing the warning instead of suppressing it
- Pre-commit hooks MUST pass (treat warnings as errors)
- If build fails with warnings, FIX the warnings - don't suppress them
- When facing extensive warnings, create a GitHub issue and systematic plan to address them

{{languageQualityEnforcementContent}}

**Exception Process (Rare):**

1. Create GitHub issue explaining why the warning cannot be fixed
2. Get team approval in issue comments
3. Use the most targeted suppression possible (function-level, not module-level)
4. Add comment explaining why and link to issue
5. Create follow-up story to address the underlying issue

**Pre-commit Hook Enforcement:**

- Pre-commit hooks are MANDATORY and must not be bypassed
- Use `git commit --no-verify` only in genuine emergencies with team notification
- If pre-commit hooks fail, fix the issues - don't bypass them

## Testing Discipline

**Universal Principles (Kent Beck TDD):**
- Work in strict Red â†’ Green â†’ Refactor loops with one failing test at a time
- Write failing tests that capture behavioral intent, no more
- Implement minimal code to make tests pass
- Refactor while keeping tests green

{{languageTestingContent}}

**Functional Core / Imperative Shell:**
- Put pure logic in the core (no I/O, no mutation beyond local scope)
- Keep an imperative shell for I/O; inject dependencies via interfaces
- Model workflows as Result pipelines (railway style)

## GitHub PR Workflow

The SPARC workflow integrates with GitHub pull requests to ensure professional development practices:

### Story Development Flow

1. **Story Selection**: Choose from PLANNING.md
2. **Branch Creation**: `story-{id}-{slug}` feature branches
3. **Standard SPARC**: Research â†’ Plan â†’ Implement â†’ Expert (with mandatory memory storage)
4. **PR Creation**: Draft PRs with comprehensive descriptions
5. **Review Loop**: Address feedback with Claude Code attribution
6. **Human Merge**: Only humans mark PRs ready-for-review

### MANDATORY Memory Storage (CRITICAL)

**Every SPARC phase MUST store knowledge in MCP memory for systematic improvement:**

- **Research Phase**: MUST store findings, sources, patterns, and API documentation
- **Planning Phase**: MUST store strategies, decisions, task breakdowns, and rationale
- **Implementation Phase**: MUST store TDD cycles, type improvements, patterns, and solutions
- **Expert Review Phase**: MUST store insights, quality patterns, and architectural analysis
- **PR Management**: MUST store workflow patterns, strategies, and outcomes

**Knowledge not stored is knowledge lost. This is not optional and will be enforced by the SPARC orchestrator.**

### Branch Management

- Feature branches: `story-001-wasm-runtime-foundation`
- Never commit to main during story development
- Branch/story mapping tracked in `.claude/branch.info`
- Automatic protection against closed PR branches

### PR Safety & Attribution

All GitHub comments from Claude Code include attribution:

```markdown
<!-- Generated by Claude Code -->
**ðŸ¤– Claude Code**: [response content]

*This comment was generated automatically...*
```

PRs created in **draft status only** - humans control ready-for-review.

### Commands & Agents

Primary commands:

- `/sparc` - Full story workflow with PR integration
- `/sparc/pr` - Create draft PR for completed story
- `/sparc/review` - Respond to PR feedback
- `/sparc/status` - Check branch/PR/story status

Subagents: researcher, planner, implementer, type-architect, test-hardener, expert, pr-manager.

After each story: run `{{lintMcpCommand}}`, `{{formatCheckMcpCommand}}`, and `{{testMcpCommand}}`.

### SPARC Coordinator Role (CRITICAL)

**When running under the `/sparc` command, the main agent (SPARC coordinator) has ONE job:**

The SPARC coordinator is STRICTLY an orchestrator and MUST NOT:

- Write or read any code directly
- Perform any research or web searches
- Create or modify any plans
- Run any commands or tests
- Make any implementation decisions
- Analyze code or requirements

The SPARC coordinator's ONLY responsibilities are:

1. **Delegate to subagents** - Use the Task tool to invoke appropriate subagents for each phase
2. **Relay information** - Pass outputs from one subagent to another as needed
3. **Interface with human** - Present subagent results to the user and collect approvals
4. **Track workflow state** - Know which SPARC phase is active and what comes next
5. **Enforce process** - Ensure all SPARC phases execute in the correct order

ALL actual work MUST be performed by the specialized subagents:

- `researcher` - Gathers information and creates research briefs
- `planner` - Creates implementation plans following TDD principles
- `red-implementer` - Writes failing tests that capture behavioral intent
- `green-implementer` - Implements minimal code to make tests pass
- `refactor-implementer` - Improves code structure while preserving behavior
- `type-architect` - Designs domain types and type-state machines
- `test-hardener` - Strengthens tests and proposes type improvements
- `expert` - Reviews code for correctness and best practices
- `pr-manager` - Handles GitHub PR operations

The coordinator is a pure orchestrator - think of it as a project manager who doesn't code.

## Code Quality Gates (CRITICAL)

**Universal Gates:**
- All linter warnings MUST be fixed, not suppressed with inline overrides
- Pre-commit hooks MUST pass without `--no-verify` bypasses
- If extensive warnings exist, create a systematic cleanup story
- Never commit code that adds new inline suppressions without explicit team approval

{{languageQualityGatesContent}}

## Property-Based Testing

**Universal Approach:**
Use property-based testing for invariants of domain types and parsers.

When a test reveals a representational gap, strengthen types so the failure becomes impossible.

{{languagePropertyTestingContent}}

## Important Instruction Reminders

Do what has been asked; nothing more, nothing less.
NEVER create files unless they're absolutely necessary for achieving your goal.
ALWAYS prefer editing an existing file to creating a new one.
NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.

**CRITICAL CODE QUALITY RULES:**
- NEVER add inline linter suppressions without explicit team approval
- NEVER bypass pre-commit hooks with `--no-verify` unless it's a genuine emergency with team notification
- ALWAYS fix linter warnings instead of suppressing them
- If facing many warnings, create a systematic cleanup story and plan - don't suppress them

{{languageCriticalRulesContent}}

**CRITICAL MEMORY STORAGE RULES:**
- EVERY agent MUST store knowledge after significant actions
- Research findings, planning decisions, implementation patterns, and insights MUST be preserved
- The SPARC orchestrator will enforce memory storage compliance
- Knowledge not stored represents wasted learning opportunities and repeated mistakes

<!-- CLAUDE.local.md -->
